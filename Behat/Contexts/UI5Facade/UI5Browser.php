<?php
namespace axenox\BDT\Behat\Contexts\UI5Facade;

use Behat\Mink\Element\NodeElement;
use Behat\Mink\Session;
use exface\Core\CommonLogic\Workbench;
use exface\Core\DataTypes\StringDataType;
use exface\Core\Facades\AbstractAjaxFacade\AbstractAjaxFacade;
use exface\Core\Factories\FacadeFactory;
use exface\Core\Factories\UiPageFactory;
use exface\Core\Factories\WidgetFactory;
use exface\UI5Facade\Facades\UI5Facade;
use PHPUnit\Framework\Assert;

/**
 * Allows to work with OpenUI5 apps generated by exface.UI5Facade
 * 
 * @author Andrej Kabachnik
 */
class UI5Browser
{ 
    private $lastError = null;

    private $session;

    private $workbench = null;

    private $facade = null;

    // Constructor
    public function __construct(Session $session, string $ui5AppUrl)
    {
        $this->session = $session;
        // XHR izleme sistemini başlat
        $this->initializeXHRMonitoring();
        $this->waitForAppLoaded($ui5AppUrl);
        $this->workbench = new Workbench();
    }

      /**
     * Initializes XHR and UI5 error monitoring.
     * 
     * Captures and logs:
     * - XMLHttpRequests (URLs, status, duration)
     * - UI5 error messages
     * - Response data and timestamps
     * 
     * Stores data in window.exfXHRLog object.
     * 
     * @return void
     */
    public function initializeXHRMonitoring(): void
    {
        $this->getSession()->evaluateScript(
            <<<JS
            (function() {
                // Initialize XHR monitoring store if not exists
                if (typeof window.exfXHRLog === 'undefined') {
                    window.exfXHRLog = {
                        requests: [],       // Array to store all XHR requests
                        lastRequest: null,  // Reference to most recent request
                        errors: []          // Collection of errors
                    };

                    // Store original XMLHttpRequest to extend its functionality
                    var originalXHR = window.XMLHttpRequest;
                    // Create custom XMLHttpRequest with monitoring
                    window.XMLHttpRequest = function() {
                        var xhr = new originalXHR();
                        var start = Date.now(); // Capture start time for duration calculation exfTools.date.format(sTime, 'yyyy-MM-dd HH:mm:ss.SSS');
                        
                        // Add listener for request completion
                        xhr.addEventListener('loadend', function() {
                            var request = {
                                url: xhr.responseURL,               // Captured request URL
                                status: xhr.status,                 // HTTP status code
                                statusText: xhr.statusText,         // HTTP status message
                                duration: Date.now() - start,       // Request duration in ms
                                response: xhr.responseText,         // Response content
                                timestamp: new Date().toISOString() // Request timestamp
                            };
                            
                            window.exfXHRLog.requests.push(request);
                            window.exfXHRLog.lastRequest = request;
                            
                            // Log non-successful responses as errors (not 2xx)
                            if (xhr.status < 200 || xhr.status >= 300) {
                                window.exfXHRLog.errors.push({
                                    type: 'HTTPError',
                                    ...request
                                });
                            }
                        });
                        
                        return xhr;
                    };
                }
                
                // Initialize UI5 error monitoring if UI5 is available
                if (typeof sap !== 'undefined' && sap.ui && sap.ui.getCore) {
                    try {
                        var core = sap.ui.getCore();
                        if (core && core.getMessageManager) {
                            var messageProcessor = {
                                getId: function() {
                                    return 'exf-xhr-message-processor';
                                },
                                // Process and log UI5 error messages
                                processMessage: function(message) {
                                    if (message.type === 'Error' || message.type === 'Fatal') {
                                        window.exfXHRLog.errors.push({
                                            type: 'UI5Error',
                                            message: message.message,
                                            details: message.description,
                                            timestamp: new Date().toISOString() //exfTools.date.format(sTime, 'yyyy-MM-dd HH:mm:ss.SSS');
                                        });
                                    }
                                },

                                // These empty methods are required by UI5's MessageProcessor interface for proper error handling

                                attachMessageChange: function() {}, // Subscribe to messages
                                detachMessageChange: function() {}, // Unsubscribe from messages
                                // Message handler interface methods
                                handleMessages: function() { return true; }, // Process messages
                                // Required lifecycle methods for UI5 system
                                init: function() {},  // Called on startup
                                exit: function() {},  // Called on cleanup
                                // Message model methods 
                                setMessages: function() {},  // Update messages
                                getMessages: function() { return []; } // Get messages
                            };
                            
                            // Try-catch processor save
                            try {
                                core.getMessageManager().registerMessageProcessor(messageProcessor);
                            } catch (e) {
                                console.warn('Message processor registration failed:', e); 
                                window.exfXHRLog.errors.push({
                                    type: 'UI5Error',
                                    message: 'Message processor registration failed',
                                    details: e.toString(),
                                    timestamp: new Date().toISOString()
                                });
                            }
                        }
                    } catch (e) {
                        console.warn('UI5 message handling setup failed:', e);
                    }
                }
            })();
            JS
        );
    }

    /**
     * Clears the XHR (XMLHttpRequest) monitoring log and resets error state
     * 
     * This function performs two main cleanup tasks:
     * 1. Clears the XHR log array in the browser (window._xhrLog)
     * 2. Resets the internal error tracking state
     * 
     * Use cases:
     * - Before starting a new test scenario
     * - After completing a test case
     * - When needing to reset monitoring state
     * - Before capturing new AJAX requests
     * 
     * Note: This should be called before any new AJAX monitoring to ensure
     * clean state and prevent mixing logs from different test scenarios
     * 
     * @return void
     * @see initializeXHRMonitoring() For the setup of the logging system
     */
    public function clearXHRLog(): void
    {
        $this->getSession()->evaluateScript(
            <<<JS
            window.exfXHRLog = {
                requests: [],
                lastRequest: null,
                errors: []
            };
            JS
        );
    }







    /**
     * Waits for OpenUI5 framework to load and initialize
     * 
     * @param int $timeoutInSeconds Maximum time to wait for UI5 loading (default: 30 seconds)
     * @return bool Returns true if UI5 loaded successfully, false otherwise
     * 
     * Step-by-step process:
     * 1. Checks if global 'sap' object exists
     * 2. Verifies sap.ui namespace is available
     * 3. Confirms sap.ui.getCore() method exists
     * 4. Validates core object is accessible
     * 5. Ensures core.getLoadedLibraries function is available
     */
    protected function waitForUI5Loading(int $timeoutInSeconds = 30): bool
    {
        return $this->getSession()->wait(
            $timeoutInSeconds * 1000,
            <<<JS
            (function() {
                // Check if base SAP namespace exists
                if (typeof sap === 'undefined') {
                    console.log('SAP not defined');
                    return false;
                }
                
                // Verify UI namespace is available
                if (typeof sap.ui === 'undefined') {
                    console.log('sap.ui not defined');
                    return false;
                }
                
                // Confirm core method exists
                if (typeof sap.ui.getCore === 'undefined') {
                    console.log('sap.ui.getCore not defined');
                    return false;
                }
                
                // Get core instance and validate
                var core = sap.ui.getCore();
                if (!core) {
                    console.log('core not available');
                    return false;
                }
                
                // Final check - ensure core libraries are loaded
                return typeof core.getLoadedLibraries === 'function';
            })()
    JS
        );
    }

    /**
     * Waits for UI5 controls to render in the page
     * 
     * @param int $timeoutInSeconds Maximum wait time (default: 30 seconds)
     * @return bool Returns true if UI5 controls are found, false if timeout reached
     * 
     * Verification process:
     * 1. Checks if UI5 framework is loaded (sap and sap.ui objects)
     * 2. Searches page content for UI5-specific markers:
     *    - 'sapUiView' - indicates presence of UI5 views
     *    - 'sapMPage' - indicates presence of UI5 mobile pages
     */
    protected function waitForUI5Controls(int $timeoutInSeconds = 30): bool
    {
        return $this->getSession()->wait(
            $timeoutInSeconds * 1000,
            <<<JS
            (function() {
                // Verify UI5 base requirements
                if (typeof sap === 'undefined' || typeof sap.ui === 'undefined') return false;
                
                // Search page content for UI5 view markers
                var content = document.body.innerHTML;
                
                // Check for either standard view or mobile page indicators
                return content.indexOf('sapUiView') !== -1 || content.indexOf('sapMPage') !== -1;
            })()
    JS
        );
    }



    /**
     * 
     * @param string $caption
     * @param \Behat\Mink\Element\NodeElement|null $parent
     * @return NodeElement|null
     */
    public function findInputByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        $page = $this->getPage();
        $input = null;
        $labelBdis = ($parent ?? $page)->findAll('css', 'label.sapMLabel > span > bdi');

        foreach ($labelBdis as $labelBdi) {
            if ($labelBdi->getText() === $caption) {
                $sapMLabel = $labelBdi->getParent()->getParent();
                $labelFor = $sapMLabel->getAttribute('for');
                $input = $sapMLabel->getParent()->getParent()->findById($labelFor);
                break;
            }
        }
        return $input;
    }

    /**
     * 
     * @param string $caption
     * @param \Behat\Mink\Element\NodeElement|null $parent
     * @return NodeElement
     */
    public function findButtonByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        $page = $this->getPage();
        // $input = $page->find('xpath', '//*/label/span/bdi[contains(text(), "' . $caption . '")]');
        // $labelBdi = $page->find('named', ['content', $caption]);
        $button = null;
        $labelBdis = ($parent ?? $page)->findAll('css', 'button.sapMBtn > span > span > bdi');
        foreach ($labelBdis as $labelBdi) {
            if ($labelBdi->getText() === $caption) {
                $button = $labelBdi->getParent()->getParent()->getParent();
                break;
            }
        }
        return $button;
    }

    public function getPage()
    {
        return $this->session->getPage();
    }

    /**
     * Waits the complete UI5 application loading process
     * 
     * @param string $pageUrl URL of the UI5 application
     * @return void
     * 
     * Loading sequence:
     * 1. Waits for initial page load completion
     * 2. Ensures UI5 framework is loaded
     * 3. Waits for UI5 controls to render
     * 4. Validates app ID presence
     * 5. Checks bussy state resolution
     * 6. Confirm AJAX requests completion
     */
    protected function waitForAppLoaded(string $pageUrl)
    {
        // Wait for initial page DOM to be ready
        $this->waitForPageIsFullyLoaded(10);

        // Ensure UI5 framework is loaded and initialized
        if (!$this->waitForUI5Loading(30)) {
            error_log("Warning: UI5 failed to load or not ready");
        }

        // Wait for UI5 controls to be rendered
        if (!$this->waitForUI5Controls(30)) {
            error_log("Warning: UI5 controls failed to load");
        }

        // Extract and validate app ID from URL
        $appId = StringDataType::substringBefore($pageUrl, '.html', $pageUrl) . '.app';
        $this->waitForNodeId($appId, 30);

        // Check app's busy state and AJAX completion
        $this->waitWhileAppBusy(30);
        $this->waitForAjaxFinished(30);
    }


    /**
     * Waits for UI5 controls to render in the page
     * 
     * @param string $componentType
     * @param int $timeoutInSeconds Maximum wait time (default: 30 seconds)
     * @return bool Returns true if UI5 controls are found, false if timeout reached
     * 
     * Verification process:
     * 1. Checks if UI5 framework is loaded (sap and sap.ui objects)
     * 2. Searches page content for UI5-specific markers:
     *    - 'sapUiView' - indicates presence of UI5 views
     *    - 'sapMPage' - indicates presence of UI5 mobile pages
     */
    public function waitForUI5Component(string $componentType, int $timeoutInSeconds = 30): bool
    {
        return $this->getSession()->wait(
            $timeoutInSeconds * 1000,
            <<<JS
            (function() {
                // Check for UI5 framework availability
                if (typeof sap === 'undefined' || typeof sap.ui === 'undefined') return false;
                
                // Look for elements with component-specific class
                var elements = document.getElementsByClassName('sap{$componentType}');
                
                // Return true if at least one component found
                return elements.length > 0;
            })()
    JS
        );
    }

    /**
     * Checks the complete UI5 application loading process
     * 
     * @param string $pageUrl URL of the UI5 application
     * @return void
     * 
     * Loading sequence:
     * 1. Waits for initial page load completion
     * 2. Ensures UI5 framework is loaded
     * 3. Waits for UI5 controls to render
     * 4. Validates app ID presence
     * 5. Checks busy state resolution
     * 6. Confirms AJAX requests completion
     */
    public function isUI5Ready(): bool
    {
        return $this->getSession()->evaluateScript(
            <<<JS
            (function() {
                // Verify UI5 framework existence
                if (typeof sap === 'undefined' || typeof sap.ui === 'undefined') return false;
                
                // Get and validate core object
                var core = sap.ui.getCore();
                
                // Check core functionality
                return core && typeof core.getLoadedLibraries === 'function';
            })()
    JS
        );
    }


    /**
     * 
     * @param string $id
     * @param int $timeoutInSeconds
     * @return void
     */
    protected function waitForNodeId(string $id, int $timeoutInSeconds = 10)
    {
        $page = $this->getPage();
        $page->waitFor(
            $timeoutInSeconds * 1000,
            function () use ($page, $id) {
                $app = $page->findById($id);
                return $app && $app->isVisible();
            }
        );
    }





    /**
     * 
     * @param int $timeoutInSeconds
     * @return bool
     */
    public function waitWhileAppBusy(int $timeoutInSeconds = 10): bool
    {
        return $this->getSession()->wait(
            $timeoutInSeconds * 1000,
            <<<JS
            (function() {
                if (document.readyState !== "complete") {
                    return false;
                }
                if ((typeof $ !== 'undefined') && $.active !== 0) {
                    return false;
                }/*
                if ((typeof XMLHttpRequest !== 'undefined') && XMLHttpRequest.prototype.readyState !== 4) {
                    return false;
                }*/
                if ((typeof exfLauncher === 'undefined') || exfLauncher === undefined) {
                    return false;
                }
                return exfLauncher.isBusy() === false;
            })()
JS
        );
    }

    /**
     * Enhanced version of waitForAjaxFinished method
     * 
     * UPDATES:
     * - Added checkAjaxRequestStatus validation
     * - Improved error detection
     * - Better handling of UI5 busy states
     * 
     * This method now:
     * 1. Waits for jQuery AJAX requests
     * 2. Checks UI5 BusyIndicator
     * 3. Validates overall AJAX status
     * 
     * @param int $timeoutInSeconds Maximum time to wait for AJAX completion
     * @return bool True if all AJAX requests completed successfully
     */
    public function waitForAjaxFinished(int $timeoutInSeconds = 10): bool
    {
        // Wait for basic AJAX completion
        $result = $this->getSession()->wait(
            $timeoutInSeconds * 1000,
            <<<JS
        (function() {
            // Check jQuery active requests
            if (typeof jQuery !== 'undefined' && jQuery.active !== 0) {
                return false;
            }

            // Check UI5 busy state
            if (typeof sap !== 'undefined' && sap.ui && sap.ui.core) {
                if (sap.ui.core.BusyIndicator._globalBusyIndicatorCounter > 0) {
                    return false;
                }
            }

            // All immediate checks passed
            return true;
        })()
        JS
        );

        // Return false if initial wait failed
        if (!$result) {
            return false;
        }

        // Perform additional validation using enhanced status check
        return $this->checkAjaxRequestStatus();
    }

    /**
     * Checks if all AJAX requests completed successfully
     * 
     * Validates HTTP status codes, UI5 errors, and busy state.
     * Stores any detected errors in lastError property.
     * 
     * @return bool true if successful, false if errors found
     * @see getLastError() For error details
     */
    public function checkAjaxRequestStatus(): bool
    {
        // First check if there's an existing error
        $error = $this->getAjaxError();
        if ($error !== null) {
            // Store the error details for later retrieval
            $this->lastError = $error;
            return false;
        }
        return true;
    }

    /**
     * Gets the last error
     */
    public function getLastError(): ?array
    {
        return $this->lastError;
    }

    /**
     * 
     * @param mixed $timeoutInSeconds
     * @return void
     */
    public function waitForPageIsFullyLoaded($timeoutInSeconds = 5)
    {
        $this->getSession()->wait(
            $timeoutInSeconds * 1000,
            <<<JS
            document.readyState === "complete"
JS
        );
    }
    /**
     * Enhanced findWidgets method with better widget detection
     * 
     * @param string $widgetType
     * @param NodeElement|null $parent
     * @param int $timeoutInSeconds
     * @return NodeElement[]
     */
    public function findWidgets(string $widgetType, NodeElement $parent = null, int $timeoutInSeconds = 2): array
    {
        // Ensure UI5 is ready
        if (!$this->isUI5Ready()) {
            $this->waitForUI5Loading($timeoutInSeconds);
        }

        // For DataTable, wait for UI5 Table components
        if ($widgetType === 'DataTable') {
            $this->waitForUI5Component('Table', $timeoutInSeconds);
            // Also wait for List component as tables might be implemented as lists
            $this->waitForUI5Component('List', $timeoutInSeconds);
        }

        // Base selector for widget
        $cssSelector = ".exfw-{$widgetType}";

        // Wait for widgets with expanded selectors
        $timeout = $this->getSession()->wait(
            $timeoutInSeconds * 1000,
            <<<JS
        (function() {
            // Check main selector
            var elements = document.querySelectorAll('{$cssSelector}');
            if (elements.length > 0) return true;
            
            // For DataTable, also check UI5 specific classes
            if ('{$widgetType}' === 'DataTable') {
                var ui5Tables = document.querySelectorAll('.sapMTable, .sapUiTable, .sapMList');
                if (ui5Tables.length > 0) return true;
            }
            
            return false;
        })()
        JS
        );

        // Get page or parent element
        $searchContext = $parent ?? $this->getPage();

        // Find widgets with the exfw class
        $widgets = $searchContext->findAll('css', $cssSelector);

        // For DataTables, also look for UI5 specific elements if no exfw widgets found
        if ($widgetType === 'DataTable' && empty($widgets)) {
            $ui5Selectors = ['.sapMTable', '.sapUiTable', '.sapMList'];
            foreach ($ui5Selectors as $selector) {
                $ui5Elements = $searchContext->findAll('css', $selector);
                $widgets = array_merge($widgets, $ui5Elements);
            }
        }

        // Filter for visible widgets only
        return array_filter($widgets, function ($widget) {
            return $widget->isVisible();
        });
    }

    /**
     * Returns the type of the widget, that the given node belongs to
     * 
     * @param \Behat\Mink\Element\NodeElement $node
     * @return bool|string|null
     */
    public function getNodeWidgetType(NodeElement $node): ?string
    {
        $classes = $node->getAttribute('class');
        $type = null;
        foreach (explode(' ', $classes ?? '') as $class) {
            if (mb_stripos($class, 'exfw-') === 0) {
                $type = StringDataType::substringAfter($class, 'exfw-');
            }
        }
        if ($type === null) {
            // TODO search the parents of the node for the first one with `exfw` CSS class
            // and take the widget type from that node
        }
        return $type;
    }

    /**
     * 
     * @return \Behat\Mink\Session
     */
    protected function getSession(): Session
    {
        return $this->session;
    }

    /**
     * 
     * @return Workbench
     */
    public function getWorkbench()
    {
        return $this->workbench;
    }

    /**
     * 
     * @return \exface\UI5Facade\Facades\UI5Facade
     */
    public function getFacade(): UI5Facade
    {
        if ($this->facade === null) {
            $this->facade = FacadeFactory::createFromString(UI5Facade::class, $this->getWorkbench());
        }
        return $this->facade;
    }

    /**
     * 
     * @param string $pageUrl
     * @param string $widgetId
     * @param string $assertWidgetType
     * @return \exface\Core\Interfaces\WidgetInterface
     */
    protected function getWidget(string $pageUrl, string $widgetId = null, string $assertWidgetType = null)
    {
        $page = UiPageFactory::createFromModel($this->getWorkbench(), $pageUrl);
        $widget = $widgetId !== null ? $page->getWidget($widgetId) : $page->getWidgetRoot();
        if ($assertWidgetType !== null) {
            Assert::assertEquals($assertWidgetType, $widget->getType(), 'Widget ' . $widgetId . ' is not of expected type "' . $assertWidgetType . '"!');
        }
        return $widget;
    }


    protected function logXHRCount(string $context = '')
    {
        $xhrCount = $this->getSession()->evaluateScript('return window._xhrLog ? window._xhrLog.length : 0;');
        echo "\n[DEBUG] " . ($context ? "{$context} - " : '') . "XHR Log Count: " . $xhrCount . "\n";
    }

    /**
     * Retrieves error information from AJAX and UI5 operations
     * 
     * Checks three sources of errors:
     * - Previous errors stored in lastError
     * - XHR logs for HTTP errors (non-200 responses)
     * - UI5 busy indicator state
     * 
     * @return array|null Error details array or null if no errors found
     * @see checkAjaxRequestStatus() For status validation
     */
    public function getAjaxError(): ?array
    {
        try {
            // Debug log ekle
            $logExists = $this->getSession()->evaluateScript('return typeof window.exfXHRLog !== "undefined";');
            echo "\nDebug - exfXHRLog exists: " . ($logExists ? 'true' : 'false') . "\n";

            // Hata logunu kontrol et
            $errors = $this->getSession()->evaluateScript('return window.exfXHRLog ? window.exfXHRLog.errors : [];') ?? [];

            if (!empty($errors)) {
                return end($errors);
            }

            // UI5 meşgul durumunu kontrol et
            $busyIndicatorCount = $this->getSession()->evaluateScript(
                'return (typeof sap !== "undefined" && sap.ui && sap.ui.core) ? ' .
                'sap.ui.core.BusyIndicator._globalBusyIndicatorCounter : 0;'
            );

            if ($busyIndicatorCount > 0) {
                return [
                    'type' => 'UI5Busy',
                    'message' => 'UI5 is still processing',
                    'busyIndicatorCount' => $busyIndicatorCount
                ];
            }

            return null;
        } catch (\Exception $e) {
            echo "\nDebug - getAjaxError Exception: " . $e->getMessage() . "\n";
            return null;
        }
    }
}
// V1
